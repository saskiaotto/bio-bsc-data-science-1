---
title: "Grundlagen in R:<br>Komplexere Objekte"
subtitle: "Data Science 1 - Programmieren & Visualisieren"
author: "Saskia Otto"
institute: "Universität Hamburg, IMF"
semester: "Wintersemester 2022/2023"
language: custom_lang.yml
format:
  revealjs:
    title-slide-attributes:
      data-background-image: images/cover_lectures.png
      data-background-size: cover
      data-background-opacity: "0.3"
    template-partials:
    - src/title-slide.html
    theme: src/uhh_theme.scss
    css: src/styles_lecture.css
    logo: images/uhh_logo_black.png
    footer: "Kurswebseite: [Data Science 1](https://saskiaotto.github.io/bio-bsc-data-science-1/)"
    slide-number: true
    # self-contained: true
    # chalkboard:
    #   buttons: true
    smaller: false
    touch: true
    controls: true
    scrollable: true
    preview-links: auto
    auto-stretch: true
    background-transition: fade
    transition-speed: fast
    # slide-tone: true
execute:
  echo: true
  warning: false
  message: false
editor: source
editor_options: 
  chunk_output_type: console
---

## Objekttypen {.smaller}

```{r setup, include=FALSE}
# If rquiz questions included:
qmd_file <- "06-r-basics-complex-objects"
lwd <- getwd()
lib_dir <- file.path(lwd, paste0(qmd_file, "_files"))
if (!dir.exists(lib_dir)) dir.create(lib_dir)

# Show countdown timer?
timer <- FALSE
```

```{r load_libraries, echo=FALSE, cache=FALSE}
library(knitr)
library(tidyverse)
```

![](images/r_intro/r_intro_sketch_objects.png){fig-align="center"}

Datenstrukturen in R lassen sich bzgl. ihrer **Dimensionalität** und der Homogenität bzw. Heterogenität ihrer **Datentypen** in fünf verschiedene Objekttypen unterscheiden: 

:::{.columns}
:::{.column .col-1}
:::
:::{.column .box-10 .box-grey2 .fragment} 

|Dimensionen | Homogen | Heterogen |
|:-----------:|:-----------:|:-------------:|
| 1D | **(Atomarer) Vektor** | Liste |
|2D | Matrix | **'Data frame'** (& 'Tibbles') |
|>2D | 'Array' |  |

:::
:::


# Listen {background="#2F4048"} 
![](images/ds_comps/ds_comp2.png){.absolute top="0" right="0" height="200"  width="auto"}


## Listen | Erstellen {.smaller}

:::{.columns}
:::{.column .col-6}  
- Sind anders als atomare Vektoren weil ihre Elemente **unterschiedliche Datentypen** und auch **Datenstrukturen** haben dürfen.
- Sie sind besonders praktisch in **Schleifen** und werden oft als **Output** von **Funktionen** verwendet.
- Werden mit `list()` erstellt:
:::

:::{.column .col-6 .fragment}  
```{r}
x <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE, TRUE), 
  c(2.3, 5.9, 1.1, 4.8, 11.0)
)
x
```
:::
:::

## Listen zählen auch zu den Vektoren  {.smaller}

:::{.columns}
:::{.column .col-6}  
![](images/r_intro/r_intro_hierarchy_vectors.png){fig-align="center"}
:::

:::{.column .col-6}  
```{r, filename="Erstellung eines Vektors vom Typ 'Liste'"}
vector("list", 2)
```

Beide Listenelemente sind erstmal leer (`NULL` steht oft für die Abwesenheit eines Vektors und verhält sich typischerweise wie ein Vektor der Länge 0). 
:::
:::

:::{.source-left}
Quelle: [R for Data Science](https://r4ds.had.co.nz/lists.html) von Wickam & Grolemund, 2017 (lizensiert unter [CC-BY-NC-ND 3.0 US](https://creativecommons.org/licenses/by-nc-nd/3.0/us/)).
:::



## Warum wird eine Liste als Vektor betrachtet?

![](images/r_intro/r_intro_lists_vs_atomic_vectors.png){fig-align="center"}


## Listen | Struktur

Eine nützliche Funktion zum Anzeigen der Objektstruktur ist `str()`:

:::{.columns}
:::{.column .col-5 .fragment}  
```{r }
x <- list(1, 2, 3)
str(x)
```
:::

:::{.column .col-7 .fragment}  
```{r }
x_named <- list(a=1, b=2, c=3)
str(x_named)
```
:::
:::


## Listen | Rekursion

- Werden manchmal als **rekursive Vektoren** bezeichnet, weil eine Liste weitere Listen enthalten kann. 
```{r, echo = TRUE}
x <- list(list(list(list("aha"))))
str(x)
```


## Visualisierung folgender Listen

```{r, echo = TRUE}
x1 <- list(c(1, 2), c(3, 4))
x2 <- list(list(1, 2), list(3, 4))
x3 <- list(1, list(2, list(3)))
```

![](images/r_intro/r_intro_list_hierarchies.png){fig-align="center"}

:::{.source-left}
Quelle: [R for Data Science](https://r4ds.had.co.nz/lists.html) von Wickam & Grolemund, 2017 (lizensiert unter [CC-BY-NC-ND 3.0 US](https://creativecommons.org/licenses/by-nc-nd/3.0/us/)).
:::


# 2- und mehrdimensionale Objekte {background="#2F4048"} 
![](images/ds_comps/ds_comp2.png){.absolute top="0" right="0" height="200"  width="auto"}


## Matrizen {.smaller}

Matrizen sind **2-dimensionale** Objekte dessen Elemente alle den **gleichen Datentyp** haben müssen. Sie werden vor allem in der numerischen Modellierung verwendet.

:::{.columns}
:::{.column .col-6 .fragment}  
- werden mit `matrix()` erstellt:

```{r}
matrix(1:6, nrow = 2, byrow = TRUE)
matrix(1:6, ncol = 2, byrow = FALSE)
```
:::

:::{.column .col-6 .fragment}  
- oder mit `cbind()` und `rbind()`:

```{r}
x <- 1:4
y <- 5:8
cbind(x, y)
rbind(x, y)
```
:::
:::


## Arrays

Arrays sind **multi-dimensionale** Objekte des **gleichen Datentyps**. Sie werden in der Datenanalyse in R aber eher selten genutzt und daher hier nicht näher beschrieben.

![](images/r_intro/r_intro_array.png){fig-align="center"}


## 'Data frames' | Was ist das?

:::{.columns}
:::{.column .col-7 .small}  
- Die **gebräuchlichste** Datenstruktur zum Speichern von Daten in R.
- Repräsentiert eine **Liste von gleich langen Vektoren** als Spalten
  - → dadurch 2-dimensionale Struktur
- Sehr flexibel da sie die gleichen Eigenschaften wie eine Liste und Matrix besitzt.
- **Datentypen** dürfen pro Vektor, also Spalte, **unterschiedlich** sein!
:::

:::{.column .col-5}
![](images/r_intro/r_intro_data_frames.png){fig-align="center"}  
:::
:::


## 'Data frames' | Erstellen
![](images/r_intro/r_intro_data_frames.png){.absolute top="10" right="0" height="100"}

:::{.columns}
:::{.column .col-11 .small}  
- 'Data frames' kann man mit der Funktion `data.frame()` erstellen, welche Vektoren mit **Namen** als Input nimmt:
:::

:::{.column .col-12 .small}  
```{r}
#| code-line-numbers: "1|2-4"
df <- data.frame(  # Achte auf den Punkt!
  x = c(5, 1, 9),           # 3 Elemente
  y = c("b", "k", "x"),     # 3 Elemente
  z = c(TRUE, FALSE, TRUE)  # 3 Elemente
) 
str(df)  # Struktur des data frames
```
:::
:::


## 'Data frames' | Aus Matrix konvertieren {.smaller}

- Matrizen lassen sich in 'data frames' umwandeln mit `as.data.frame()` und wieder zurück mit `as.matrix()` (solange der Datentyp gleich ist):

:::{.columns}
:::{.column .col-6 .fragment}  
```{r }
x <- 1:3
y <- 4:6
mat <- cbind(x, y)
mat
```
:::

:::{.column .col-6 .fragment}  
```{r }
mat2df <- as.data.frame(mat)
mat2df
as.matrix(mat2df)
```
:::
:::


## Längenattribute {.smaller}

`length()` in **2- und multi-dimensionalen Objekten** lässt sich verallgemeinern zu

:::{.columns}
:::{.column .col-6}
- `nrow()` and `ncol()` bei 2 Dimensionen
```{r}
nrow(df)
ncol(df)
nrow(mat)
ncol(mat)
```
:::

:::{.column .col-6}
- `dim()` bei 2 oder 3 Dimensionen
```{r}
dim(df)
dim(mat)
```
<span style="font-size:16px;">(zeigt erst die Zeile, dann die Spalte, dann ggf. die Anzahl der 3. Dim.)</span>
:::
:::


## Namensattribute

`names()` zeigt in 'data frames' den Spaltennamen an:
```{r}
names(df)
```

:::{.fragment}
Diese können auch überschrieben werden:
```{r}
names(df) <- c("x_neu", "y_neu", "z_neu")
df
```
:::


## Erste und letzte Zeilen anzeigen {.smaller}

```{r}
head(iris)
```

```{r}
tail(iris)
```


# 2-dimensionale Indexierung {background="#2F4048"} 
![](images/ds_comps/ds_comp2.png){.absolute top="0" right="0" height="200"  width="auto"}


## Indexierung | `[Zeilen, Spalten]` {.smaller}

- Die Indexierung von Matrizen und 'data frames' funktioniert genauso **wie die Vektor-basierte** Indexierung, nur dass die **Auswahl** für **jede Dimension** erfolgen muss.
- Es wird **jede** Dimension mit einem **1D Index** getrennt durch ein Komma angegeben (*'integer', 'logical', oder 'character'* Indizes sind erlaubt). 
- **Leere Indizes** sind erlaubt um alle Zeilen bzw. Spalten auszuwählen.

:::{.columns}
:::{.column .col-6 .fragment} 
```{r, filename="Anhand der Position auswählen"}
df[ , 1:2] # alle Zeilen, Spalte 1-2
df[c(1,3), 2] # Zeile 1+3, Spalte 2
```
:::

:::{.column .col-6 .fragment} 
```{r, filename="Anhand der Namen auswählen"}
# alle Zeilen, Spalte 'x_neu':
df[ , c("x_neu") ]
```
:::
:::


## Neue Objekte über Indexierung erstellen

Teile einer Matrix mittels Positionsindexierung auswählen und neu abspeichern:
```{r}
#| code-line-numbers: "2"
mat <- matrix(1:90, ncol = 10, byrow = TRUE)
new_mat <- mat[c(1,4), 2:7]
new_mat
```


## Positionsindexierung genauer erklärt

![](images/r_intro/r_intro_matrix_extraction.png){fig-align="center"}


## Spalten-Indexierung | `$` {.smaller}

- `$` ist eine **Kurzschreibweise** ('shorthand notation') zum Extrahieren von benannten Elementen in einer Liste.
- Da 'data frames' Listen von Vektoren darstellen (in Spalten angelegt), kann diese Kurzschreibweise hier auch zur **Auswahl von Spalten** verwendet werden:

:::{.columns}
:::{.column .col-6 .fragment} 
```{r, filename="Ganze Spalten auswählen"}
df
df$y_neu
df[ ,2] # das gleiche 
```
:::

:::{.column .col-6 .fragment} 
```{r, filename="Spaltenwahl + Vektorenindexierung"}
df$x_neu[1]
df$y_neu[1:2]
df$z_neu[c(1,3)]
```
:::
:::


## Daten filtern mit logischer Indexierung | Calc vs. R

- Typischerweise **filtert** man die **Zeilen**, nicht die Spalten (wie auch in Calc): <br>`df[Zeilenabfrage, Spalten]`
- D.h. der Zeilenindex stellt eine **Abfrage** dar, und diese bezieht sich aber immer auf **Elemente der ausgewählten Spalte(n)**.


## Daten filtern mit logischer Indexierung | Calc vs. R - ein Vergleich {.smaller}

Wähle alle Spalten, aber nur die Zeilen, wo die Werte in Spalte 'x_neu' >= 5 sind.

:::{.columns}
:::{.column .box-6 .box-green}
### Calc
![](images/r_intro/r_intro_calc_filter.png){fig-align="center"}
:::

:::{.column .box-6 .box-blue .fragment} 
### R
```{r}
df
```

```{r}
df[df$x_neu >=5, ]
```
:::
:::


## Daten filtern mit logischer Indexierung | Weitere Beispiele {.smaller}
 

```{r}
# Wähle alle Spalten, aber nur die Zeilen mit den Werten TRUE in 'z_neu'
df[df$z_neu == TRUE, ]

# Wähle nur Spalte 1 und 2 und die Zeilen, die in 'y_neu' ein "k" enthalten
df[df$y_neu == "k", 1:2]
```


## Werte mittels Indexierung ersetzen {.smaller}

:::{.columns}
:::{.column .col-5} 
```{r}
df
df[1,1]
df[1,1] <- NA
df$z_neu[3] <- FALSE
df
```
:::

:::{.column .col-7} 
![](images/r_intro/r_intro_lindt_calendar.png){fig-align="center"}
:::
:::


## Neue Spalten (Vektoren) mit dem `$` Operator anhängen {.smaller}

```{r}
df$z_neuer <- rep("FALSE", 3)
df$x_log <- log(df$x_neu)
df$x_char <- as.character(df$x_neu)
df
```


# Your turn ... {background="radial-gradient(yellow, green)"} 
![](images/icons/action.png){.absolute top="0" right="0" height="100"  width="auto"}

```{r}
#| echo: false
#| eval: !expr timer
countdown::countdown(minutes = 0, seconds = 40, font_size= "3em")
```


## Quiz 1 | `iris` - Objekttyp {.smaller}
![](images/icons/action.png){.absolute top="10" right="0" height="75"}

Schau Dir folgenden Datensatz an:
```{r, eval = TRUE}
head(iris, 3)
```

::: {.panel-tabset}
### Quiz
```{r, echo=FALSE}
myQuestion <- list(
  question = "Zu welchem Objekttyp gehört der 'iris' Datensatz",
  options = c("Vektor", "Liste", "Matrix", "Data frame"),
  answer = 4
  )
rquiz::singleQuestion(x = myQuestion)
```

### Tipp
Der Datensatz ist 2-dimensional und die Spalten haben unterschiedliche Datentypen (heterogen).
:::


## Quiz 2 | `iris` - Objektstruktur {.smaller}
![](images/icons/action.png){.absolute top="10" right="0" height="75"}

Schau Dir die Struktur vom `iris` Datensatz an:
```{r, eval = TRUE}
str(iris)
```

::: {.panel-tabset}
### Quiz
```{r, echo=FALSE}
myQuestion <- list(
  question = "Wie groß sind die Dimensionen im 'iris' Datensatz",
  options = c("5 Zeilen, 150 Spalten", "150 Zeilen, 5 Spalten", "Die Dimensionsgrößen sind dem Output nicht zu entnehmen."),
  answer = 2
  )
rquiz::singleQuestion(x = myQuestion)
```

### Tipp
In einem geordneten, sauberen Datensatz sind die Variablen immer spaltenmäßig angeordnet und die Beobachtungseinheiten (observations) zeilenmäßig. 'iris' enthält 150 Beobachtungen und 5 Variablen, sprich 150 Zeilen und 5 Spalten.
:::


# Data frames numerisch zusammenfassen {background="#2F4048"} 
![](images/ds_comps/ds_comp3.png){.absolute top="0" right="0" height="200"  width="auto"}


## Übersicht der built-in Funktionen

:::{.columns}
:::{.column .col-8 .xx-small}

Funktion | Statistik
---------|-------------
`sum()` | Summe
`mean()` | Arithmetischer Mittelwert
`median()` | Median
`min()` | Minimalwert
`max()` | Maximalwert
`range()` | Bereich zwischen Minimum und Maximum
`var()` | Varianz
`sd()` | Standardabweichung
`quantile()` | Quantilen
`cov()` | Kovarianz
`cor()` | (Pearsons) Korrelationskoeffizient
`summary()` | Berechnet unterschiedliche Statistiken
:::

:::{.column .col-4 .small}
Es gibt keine built-in Funktion für den Standardfehler und den Variationskoeffizienten sowie die Schiefe und Kurtosis!
:::
:::


## Beispiel: Mittelwert 

```{r}
x <- 1:30
```

:::{.columns}
:::{.column .col-12 .fragment} 
```{r}
# Manuelle Berechnung
sum(x) / length(x)
```
:::

:::{.column .col-12 .fragment} 
```{r, echo=TRUE}
# Built-in Funktion
mean(x)
```
:::
:::


## Deskriptive Zusammenfassung {.smaller}
### Shortcut mit `summary()`

```{r, echo=TRUE}
head(iris)
summary(iris)
```


## Berechnung einer linearen Regression | 1
### Zusammenhang zwischen der Kelch- und Kronblattlänge

```{r}
#| code-fold: true
plot(x = iris$Sepal.Length, y = iris$Petal.Length,
  xlab = "Kelchblattblänge", ylab = "Kronblattlänge",
  main = "Streudiagramm zur Darstellung von Beziehungen")
```


## Berechnung einer linearen Regression | 2 {.smaller}
### Der Steigungsparameter

:::{.columns}
:::{.column .box-5 .box-orange}
### Steigung *b*

\begin{align}
b&=\frac{\sum x_iy_i}{\sum x_i^2}\\
&= \frac{\sum[(x_i-\bar{x})*(y_i-\bar{y})]}{\sum(x_i-\bar{x})^2} \\
&= \frac{SS_{XY}}{SS_{X}} = \frac{cov_{XY}}{s_{x}^2}\\
\end{align}

:::

:::{.column .box-7 .box-orange .fragment}
```{r}
# Vektorspeicherung um Tipparbeit zu sparen
x <- iris$Sepal.Length
y <- iris$Petal.Length
# Berechnung der Mittelwerte
x_mean <- mean(x)
y_mean <- mean(y)

# Berechnung von b - langer Weg
ss_xy <- sum( (x-x_mean)*(y-y_mean) )
ss_x <- sum((x-x_mean)^2 )
b <- ss_xy/ss_x
b
# Berechnung von b - kurzer Weg
(b <- cov(x, y) / var(x))
```
:::
:::


## Berechnung einer linearen Regression | 3 {.smaller}
### Der y-Achsenabschnitt

:::{.columns}
:::{.column .box-6 .box-yellow}
### y-Achsenabschnitt *a*
$\bar{y} = a -b\bar{x}$

→ Da die Regressionslinie durch das Zentrum der Datenwolke geht (also durch den Mittelwert von *x* und *y*), braucht diese Formel nur nach *a* umgeformt werden:

$a = \bar{y}-b\bar{x}$

:::

:::{.column .box-6 .box-yellow .fragment}
```{r}
a <- y_mean - b*x_mean
a
```
:::
:::


## Berechnung einer linearen Regression | 4 {.smaller}
### Die Regressionsgerade mit einzeichnen

```{r}
#| code-line-numbers: "4"
plot(x = iris$Sepal.Length, y = iris$Petal.Length,
  xlab = "Kelchblattblänge", ylab = "Kronblattlänge",
  main = "Streudiagramm zur Darstellung von Beziehungen")
abline(a = a, b = b)
```


# Übungsaufgabe {background=#191919}
![](images/ds_comps/ds_comp2.png){.absolute top="0" right="0" height="200"  width="auto"}

## Installation des *tidyverse* Pakets

Damit die nächsten swirl-Lektionen problemlos laufen und als Vorbereitung für die anschließenden swirl-Kurse sollte das *tidyverse* Paket installiert werden (mehr Informationen zum Paket gibt es in den nächsten Vorlesungen):

```{r}
#| eval: false
install.packages("tidyverse")
```


## Zu bearbeitende Swirl-Lektionen {.smaller}
![](images/icons/computer.png){.absolute top="10" right="0" height="75"}

### Kurs *DS1-01-R Grundlagen*

- **L13-Listen**
- (L14-Matrizen und Arrays)
- **L15-Data frames**
- (L16-Praktische Tipps rund ums Programmieren)

### Kurs *DS1-03-Datenexploration mit R*

- **L01-Erste numerische Analyse**
- (L08-Regressionsgerade berechnen)


## Lernziele
![](images/icons/checklist2.png){.absolute top="10" right="0" height="75"}

### Am Ende dieser Übungseinheit sollten Sie ... 

- ..einen Überblick über alle Objekte in R haben.
- ..Daten bzw. Elemente von Objekten filtern, auswählen und ändern können.
- ...deskriptive Statistiken wie den Mittelwert, Median oder die Varianz in R berechnen können.
- ..sauberen Programmcode schreiben können.
- ..selbständig einen Algorithmus entwickeln und in R Code umwandeln können.



# Wie fühlen Sie sich jetzt...?  {background=#B40014}

## Total konfus? {.smaller}
![](images/comics/comic_confused_black.png){.absolute top="50" right="30" height="400" width="auto"}
<br>

::: {.columns}
:::{.column .box-6 .box-red .small}
### Keine Sorge...
... im swirl-Kurs wirst Du direkt an die Hand genommen und Stück für Stück angeleitet.
:::
:::


## Überblick aller Objekttypen

![](images/r_intro/r_intro_object_overview_cheatsheet.png){fig-align="center"}

::: {.source-left}
Siehe auch DSB cheatsheet *Basic R functions* (auf Moodle).
:::



## Überblick aller Objektindexierungen

![](images/r_intro/r_intro_object_indexing_cheatsheet.png){fig-align="center"}

::: {.source-left}
Siehe auch DSB cheatsheet *Basic R functions* (auf Moodle).
:::


## Total gelangweilt?
![](images/comics/comic_bored.png){width="800px" height="auto" fig-align="center"}
                
::: {.r-fit-text}
Dann mach doch einfach die nächsten *swirl* Lektionen auch schon...
:::



## {background="#2F4048"} 

<div id="end-slide">
  <img src="images/uhh_logo_white.png" style="width:200px; height:auto">
  <p>Bei weiteren Fragen: saskia.otto(at)uni-hamburg.de<br><br>
    <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
      <img alt="Creative Commons License" style="border-width:0"
        src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br>
        Diese Arbeit is lizenziert unter einer <a rel="license" 
          href="http://creativecommons.org/licenses/by-sa/4.0/">
        Creative Commons Attribution-ShareAlike 4.0 International License </a>
      mit Ausnahme der entliehenen und mit Quellenangabe versehenen Abbildungen.<br>
  </p>
</div>
